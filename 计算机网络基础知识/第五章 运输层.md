> \4. 传输层
>\1. UDP，次要一点，掌握特点和首部各个字段
> \2. 掌握TCP
>    \1. 特点 + 首部字段 + 可靠机制
>    \2. 连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）
>      \3. 流量控制机制：滑动窗口,慢启动，拥塞避免，快速重传，快速恢复
>      \4. 超时重传机制

# 第五章 运输层

## 5.1 概述

### 运输层的作用范围

![image-20210827204604329](images/image-20210827204604329.png)

### 计算机网络体系结构的角度理解运输层

![image-20210827205149639](images/image-20210827205149639.png)

注意，以上端口并非物理端口，而是**指用来区分不同应用进程的标识符。**

为了简单起见，可以理解为运输层直接为应用进程间的逻辑通信提供服务，如下图所示：

![image-20210827205437666](images/image-20210827205437666.png)

### 小结

![image-20210827205504546](images/image-20210827205504546.png)



## 5.2 端口号、复用、分用的概念

### 端口号

![image-20210827213221090](images/image-20210827213221090.png)



### 发送方的复用和接收方的分用

![image-20210827214753728](images/image-20210827214753728.png)

![image-20210827214915942](images/image-20210827214915942.png)

### 运输层端口号的作用——实例

用户PC、DNS服务器、Web服务器通过交换机进行互连，处于同一个以太网中。

DNS服务器中记录有：Web服务器的域名所对应的IP地址

例子：

![image-20210827231533298](images/image-20210827231533298.png)

DNS查询请求报文——UDP用户数据报（DNS查询请求）——UDP用户数据报（DNS响应）——TCP报文段（HTTP请求报文）——TCP报文段（HTTP响应报文）

其他图片略。



## 5.3 UDP和TCP的对比

UDP，User Datagram Protocol，用户数据报协议

TCP，Transmission Control Protocol，传输控制协议

### 数据传输

![image-20210828095119864](images/image-20210828095119864.png)

### 支持的通信

![image-20210828095311734](images/image-20210828095311734.png)

### 对应用报文的处理

UDP对应用进程交下来的报文既不合并也不拆分，而且保留这些报文的边界，即**UDP是面向应用报文**的。

而发送方的TCP把应用进程交付下来的数据块仅仅看作是一连串的、无结构的字节流，TCP并不知道这些待传送的字节流的含义，仅讲它们编号并存储在自己的**发送缓存**中。TCP根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送。

接收方的TCP一方面从接收到的TCP报文段中，取出数据载荷并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程。

TCP**不保证**接收方应用进程所收到的数据块与发送方应用进程所发出的数据块具有对应大小的关系。（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用进程。）但接收方应用进程收到的字节流必须和发送方应用进程发出的字节流完全一样。接收方的应用进程必须有能力识别收到的字节流，并还原成有有意义的应用层数据。**TCP是面向字节流的。**![image-20210828101007914](images/image-20210828101007914.png)

### 提供的服务

![image-20210828101518373](images/image-20210828101518373.png)

### 首部格式

![image-20210828101627639](images/image-20210828101627639.png)

### 小结

![image-20210828101650920](images/image-20210828101650920.png)



## 5.4 TCP的流量控制

![image-20210828101817140](images/image-20210828101817140.png)



TCP接收方利用自己的**==接收窗口==**的大小来限制发送方**==发送窗口==**的大小；

TCP发送方收到接收方的**==零窗口通知==**后，应启动==**持续计时器**==。持续计时器超时后，向接收方发送**==零窗口探测报文==**。

![image-20210828104702148](images/image-20210828104702148.png)

![image-20210828104717078](images/image-20210828104717078.png)

![image-20210828104738061](images/image-20210828104738061.png)



## 5.5 TCP的拥塞控制

![image-20210828142527170](images/image-20210828142527170.png)

TCP的四种拥塞控制算法：

![image-20210828142712463](images/image-20210828142712463.png)

![image-20210828142843011](images/image-20210828142843011.png)

### 慢开始（cwnd指数增长）

传输轮次是指：发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段。一个传输轮次所经历的时间就是往返时间（并非恒定数值）。

发送的最初执行慢开始，令 拥塞窗口cwnd = 1，慢开始门限值ssthresh  = 16，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

![image-20210828143747374](images/image-20210828143747374.png)

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。

当 cwnd >= ssthresh 时，进入拥塞避免:

### 拥塞避免（cwnd线性+1）

进入拥塞避免，每个轮次只将 cwnd **加 1。**即：

![image-20210828144317355](images/image-20210828144317355.png)

假设在传输过程中有的报文段出现了丢失，则必定会触发发送方对这些丢失的报文段的超时重传。此时，**判断网络很可能出现了拥塞**，则令 **ssthresh = cwnd / 2，然后重新执行慢开始**：

![image-20210828144603945](images/image-20210828144603945.png)

慢开始算法到慢开始门限值后，同理再执行拥塞避免算法：

![image-20210828144711353](images/image-20210828144711353.png)

- 两个算法的小结

![image-20210828145213187](images/image-20210828145213187.png)

💡慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；

💡拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长。



### 快重传

![image-20210828145313488](images/image-20210828145313488.png)

![image-20210828145344503](images/image-20210828145344503.png)

💡快重传算法的机制如下：

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，**如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段**。例如收到三个 M2，则 M3 丢失，立即重传 M3。

![image-20210828145726874](images/image-20210828145726874.png)

对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞。使用快重传可以使得整个网络的吞吐量提高约20%。



### 快恢复

![image-20210828150632791](images/image-20210828150632791.png)

![image-20210828150646236](images/image-20210828150646236.png)



![image-20210828150657811](images/image-20210828150657811.png)



### 小结

![image-20210828143137226](images/image-20210828143137226.png)





## 5.6 TCP超时重传时间RTO的选择

### 分析

超时重传时间的选择是TCP最复制的问题之一

如果RTO太小：

<img src="images/image-20210828151520400.png" alt="image-20210828151520400" style="zoom: 33%;" />

如果RTO太大：

<img src="images/image-20210828151554557.png" alt="image-20210828151554557" style="zoom:33%;" />

因此，**RTO应该略大于往返时间RTT**。但是TCP下层是复杂的互联网环境，往返时间RTT是不固定的：

<img src="images/image-20210828151834525.png" alt="image-20210828151834525" style="zoom:33%;" />

![image-20210828151910369](images/image-20210828151910369.png)

### 计算公式

![image-20210828152020307](images/image-20210828152020307.png)

由公式可知，RTT~S~和RTT~D~都是基于所测量得到的RTT样本进行计算的，但是往返时间RTT的测量也是比较复杂的：

![image-20210828152340538](images/image-20210828152340538.png)

![image-20210828152459815](images/image-20210828152459815.png)

​	



RTO的计算举例

![image-20210828152659825](images/image-20210828152659825.png)

### 小结

![image-20210828152802256](images/image-20210828152802256.png)



## 5.7 TCP可靠传输的实现

### 机制

![image-20210828155034234](images/image-20210828155034234.png)

### 举例

![image-20210828153548170](images/image-20210828153548170.png)

![image-20210828153651321](images/image-20210828153651321.png)



### 说明

![image-20210828154637178](images/image-20210828154637178.png)



## 💡5.8 TCP的运输连接管理

![image-20210828155333763](images/image-20210828155333763.png)



### 5.8.1 TCP的连接建立——三报文握手

需要解决发问题：

![image-20210828155655903](images/image-20210828155655903.png)

#### 机制

首先，两端都处于关闭状态。

一开始，TCP服务器进程首先创建**传输控制块**，用来存储TCP连接中的一些重要信息。之后就准备接收TCP客户进程的连接请求，进入**监听状态**。

<img src="images/image-20210828160414426.png" alt="image-20210828160414426" style="zoom: 50%;" />

TCP服务器进程是被动等待来自TCP客户进程的连接请求，也称为被动打开连接：

![image-20210828160609322](images/image-20210828160609322.png)

TCP客户进程也是首先创建传输控制块，然后在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。TCP连接请求报文段首部中的**同步位SYN=1**（表明这是一个TCP连接请求报文段），**序号字段seq被设置了一个初始值x**，**作为TCP客户进程所选择的初始序号。**

注意，SYN=1的报文段不能携带数据。

![image-20210828161148302](images/image-20210828161148302.png)



TCP服务器进程收到连接请求报文，如果同意建立连接，则向 TCP客户进程发送**连接确认报文**，同步位SYN=1，**确认位ACK=1**，**确认号ack = x+1（这是对TCP客户进程所选择的初始序号的确认）**，同时也选择一个初始的序号 y，作为TCP服务器进程所选择的初始序号。

![image-20210828163508781](images/image-20210828163508781.png)

TCP客户进程收到连接确认报文后，还要向TCP服务器进程发送一个**普通的TCP确认报文段（ACK=1）**，**确认号为 y+1（这是对TCP服务器进程所选择的初始序号的确认）**，seq=x+1。

![image-20210828161851864](images/image-20210828161851864.png)

TCP服务器进程收到确认报文段后也进入连接已建立状态：

![image-20210828163749876](images/image-20210828163749876.png)



#### 是否多余的思考

能否使用“两报文握手”建立连接呢？答案是不能。举例说明：

![image-20210828164106560](images/image-20210828164106560.png)

所以，三握手并不多余！这是为了防止已失效的连接请求报文突然又传送到了TCP服务器，从而导致错误。

#### 课上习题

![image-20210828164435318](images/image-20210828164435318.png)

#### 小结

![image-20210828163749876](images/image-20210828163749876.png)

![image-20210828164519129](images/image-20210828164519129.png)

### 5.8.2 TCP的连接释放——四报文挥手

> 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。
>
> **TIME_WAIT**
>
> 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
>
> - 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
> - 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

#### 机制

 - TCP客户进程发送TCP连接释放报文段，并进入**终止等待-1状态。**

**终止位FIN和确认位ACK**都被设置为1——表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；

**序号seq**=u，等于TCP客户之前已传送过的数据的最后一个字节序号加1；

**确认号ack**=v，等于TCP客户进程之前已收到的、数据的最后一个字节的序号+1；

![image-20210828170205120](images/image-20210828170205120.png)

- TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入**关闭等待状态**。

ACK=1——表明这是一个普通的TCP确认报文段；

seq=v，等于TCP服务器进程已传送过的数据的最后一个字节的序号加1；

ack=u+1，这是对TCP连接释放报文段的确认；

TCP服务器进程这时应通知高层应用进程：TCP客户进程要断开TCP连接。

此时，TCP客户进程——>TCP服务器进程这个方向的连接就释放了，TCP连接处于**半关闭状态**。即，TCP客户进程已无数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收。

![image-20210828170216999](images/image-20210828170216999.png)

TCP客户进程收到TCP确认报文段后就进入**终止等待2状态**，等待TCP服务器进程发出的TCP连接释放报文段：

若使用TCP服务器进程的应用进程没有数据要发送了，应用进程就通知器TCP服务器释放连接（被动关闭连接）：

![image-20210828170249310](images/image-20210828170249310.png)

- TCP服务器进程发送TCP连接释放报文并进入**最后确认状态**

FIN=1，ACK=1——表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；

seq = w，在半关闭状态下，TCP服务器进程可能又发送了一些数据；

ack= u+1，这是对之前收到的TCP连接释放报文的重复确认；

![image-20210828201240395](images/image-20210828201240395.png)

- TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送**普通的TCP确认报文段**，之后进入**时间等待状态**

ACK=1——表明这是一个普通的TCP确认报文段；

seq=u+1，这是因为之前发送的TCP释放报文段消耗了一个序号；

ack = w+1，这是对所收到的TCP连接释放报文段的确认；

![image-20210828202358084](images/image-20210828202358084.png)

TCP服务器进行收到该报文段后就进入**关闭状态**，而TCP客户进程还有经过**2MSL后才能进入关闭状态**。

![image-20210828202627676](images/image-20210828202627676.png)

#### 等待是否多余的思考

![image-20210828202905058](images/image-20210828202905058.png)

- 确保最后一个确认报文能够到达。如上图所示，TCP服务器进程没收到 TCP客户进程发送来的确认报文，那么就会重新发送连接释放请求报文，TCP客户进程等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的**所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文

#### TCP保活计时器的作用

![image-20210828203355221](images/image-20210828203355221.png)

#### 小结

![image-20210828203702878](images/image-20210828203702878.png)

## 💡5.9 TCP报文段的首部格式

![image-20210828203834704](images/image-20210828203834704.png)

首部格式：与IP数据报的首部格式类似（固定首部+扩展首部）

![image-20210828203923844](images/image-20210828203923844.png)

### 源端口和目的端口

![image-20210828204041694](images/image-20210828204041694.png)

端口的作用举例：

![image-20210828204157265](images/image-20210828204157265.png)

![image-20210828204214037](images/image-20210828204214037.png)

![image-20210828204227629](images/image-20210828204227629.png)

### 与实现可靠传输相关的字段

#### 序号

![image-20210828204504610](images/image-20210828204504610.png)

#### 确认号

![image-20210828204555469](images/image-20210828204555469.png)

#### 确认标志位ACK

![image-20210828204619860](images/image-20210828204619860.png)

#### 作用举例

![image-20210828204712692](images/image-20210828204712692.png)

![image-20210828204803995](images/image-20210828204803995.png)

### 数据偏移

![image-20210828204835735](images/image-20210828204835735.png)

举例说明：

![image-20210828205148910](images/image-20210828205148910.png)

### 保留

![image-20210828205209908](images/image-20210828205209908.png)

### 窗口字段

![image-20210828205227968](images/image-20210828205227968.png)

发送窗口的大小还取决于拥塞窗口的大小，要从接收窗口和拥塞窗口中取小者。

### 校验和

![image-20210828205403401](images/image-20210828205403401.png)

### 同步标志位SYN

![image-20210828205449490](images/image-20210828205449490.png)

### 终止标识位FIN

![image-20210828205624803](images/image-20210828205624803.png)

### 复位标志位RST

![image-20210828205651284](images/image-20210828205651284.png)

### 推送标志位PSH

![image-20210828205726263](images/image-20210828205726263.png)

### 紧急标志位URG和紧急指针

![image-20210828205818147](images/image-20210828205818147.png)



### 选项

![image-20210828205936144](images/image-20210828205936144.png)

### 填充

![image-20210828205958008](images/image-20210828205958008.png)

### 小结

![image-20210828210029183](images/image-20210828210029183.png)

